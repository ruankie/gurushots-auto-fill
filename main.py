import osimport platformimport sysimport threadingimport timeimport PyQt5from PyQt5 import QtCore, QtWidgets, QtGui, QtPrintSupportfrom PyQt5.QtCore import *from PyQt5.QtCore import QSettingsfrom PyQt5.QtGui import *from PyQt5.QtWidgets import *from PyQt5.QtWidgets import QApplicationfrom qtpy import uicfrom PyQt5.QtCore import QSettings, QStandardPathsimport undetected_chromedriver as ucfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECimport numpy as npfrom selenium.webdriver.common.keys import Keysdef OsFind():    global osCheck    if platform.system() == "Darwin":        osCheck = "Darwin"    elif platform.system() == "Windows":        osCheck = "Windows"    elif platform.system() == "Linux":        osCheck = "Linux"    return osCheckdef Settings():    # check that this is Mac User    global settings    if OsFind() == "Darwin":        path = QStandardPaths.writableLocation(QStandardPaths.GenericDataLocation)        settings = QSettings(path + "/__settings.ini", QSettings.IniFormat)    # check that this is Windows User    elif OsFind() == "Windows" or OsFind() == "Linux":        settings = QSettings("__settings.ini", QSettings.IniFormat)    return settingsdef GetPaths():    if getattr(sys, 'frozen', False):        app_path = os.path.dirname(sys.executable)    else:        app_path = os.path.dirname(__file__)    return app_path_UI = GetPaths() + '/UI/main.ui'class MainWindow(QMainWindow, QtWidgets.QWidget):    def __init__(self):        super(MainWindow, self).__init__()        uic.loadUi(_UI, self)  # Load the ui into self        self.Run = True        self.setting = Settings()        self.SetData()        self.LOGIN_WAIT = int(self.LOGIN_WAIT_APP.text())  # max time to wait for login elements to load        self.IMPLICIT_WAIT = int(self.IMPLICIT_WAIT_APP.text())  # implicit wait time        self.LOW_WAIT_TIME_BETWEEN_CHALLENGES = float(            self.LOW_WAIT_TIME_BETWEEN_CHALLENGES_APP.text())  # lower limit of wait time between filling chllenges        self.HIGH_WAIT_TIME_BETWEEN_CHALLENGES = float(            self.HIGH_WAIT_TIME_BETWEEN_CHALLENGES_APP.text())  # upper limit of wait time between filling chllenges        self.LOW_WAIT_TIME_BETWEEN_VOTES = float(            self.LOW_WAIT_TIME_BETWEEN_VOTES_APP.text())  # lower limit of wait time between voting for photos        self.HIGH_WAIT_TIME_BETWEEN_VOTES = float(            self.HIGH_WAIT_TIME_BETWEEN_VOTES_APP.text())  # upper limit of wait time between voting for photos        self.FILL_THRESHOLD = float(self.FILL_THRESHOLD_APP.text())  # only vote if exposure less than this        self.BOOST = self.comboBoxBOOST_APP.currentText()  # whether ot not to boost where free boosts are available        self.HEADLESS = self.comboBoxHEADLESS_APP.currentText()  # whether or not to run Chrome headless        # buttons actions        self.btnStart.clicked.connect(self.RunAppThreading)        self.btnSaveOptions.clicked.connect(self.SaveOptions)        self.btnSaveLogin.clicked.connect(self.SaveLogin)        self.btnStop.clicked.connect(self.StopRunning)        self.frameCounter.hide()    def StopRunning(self):        self.driver.close()        self.driver.quit()        self.statusbar.showMessage('Stopped')        self.textEditLogs.append('Stopped the program')        self.Run = False    def SetData(self):        if self.setting.value("USERNAME") and self.setting.value("PASSWORD"):            self.userNameLineEdit.setText(self.setting.value("USERNAME"))            self.passwordLineEdit.setText(self.setting.value("PASSWORD"))        if self.setting.value("LOGIN_WAIT"):            self.LOGIN_WAIT_APP.setText(str(self.setting.value("LOGIN_WAIT")))        if self.setting.value("IMPLICIT_WAIT"):            self.IMPLICIT_WAIT_APP.setText(str(self.setting.value("IMPLICIT_WAIT")))        if self.setting.value("LOW_WAIT_TIME_BETWEEN_CHALLENGES"):            self.LOW_WAIT_TIME_BETWEEN_CHALLENGES_APP.setText(str(self.setting.value("LOW_WAIT_TIME_BETWEEN_CHALLENGES")))        if self.setting.value("HIGH_WAIT_TIME_BETWEEN_CHALLENGES"):            self.HIGH_WAIT_TIME_BETWEEN_CHALLENGES_APP.setText(str(self.setting.value("HIGH_WAIT_TIME_BETWEEN_CHALLENGES")))        if self.setting.value("LOW_WAIT_TIME_BETWEEN_VOTES"):            self.LOW_WAIT_TIME_BETWEEN_VOTES_APP.setText(str(self.setting.value("LOW_WAIT_TIME_BETWEEN_VOTES")))        if self.setting.value("HIGH_WAIT_TIME_BETWEEN_VOTES"):            self.HIGH_WAIT_TIME_BETWEEN_VOTES_APP.setText(str(self.setting.value("HIGH_WAIT_TIME_BETWEEN_VOTES")))        if self.setting.value("FILL_THRESHOLD"):            self.FILL_THRESHOLD_APP.setText(str(self.setting.value("FILL_THRESHOLD")))        if self.setting.value("BOOST"):            self.comboBoxBOOST_APP.setCurrentText(str(self.setting.value("BOOST")))        if self.setting.value("HEADLESS"):            self.comboBoxHEADLESS_APP.setCurrentText(str(self.setting.value("HEADLESS")))        if self.setting.value("WaitToReCheck"):            self.WaitToReCheck.setText(str(self.setting.value("WaitToReCheck")))            self.label.setText(str(self.setting.value("WaitToReCheck")))    def SaveOptions(self):        self.setting.setValue("LOGIN_WAIT", self.LOGIN_WAIT_APP.text())        self.setting.setValue("IMPLICIT_WAIT", self.IMPLICIT_WAIT_APP.text())        self.setting.setValue("LOW_WAIT_TIME_BETWEEN_CHALLENGES", self.LOW_WAIT_TIME_BETWEEN_CHALLENGES_APP.text())        self.setting.setValue("HIGH_WAIT_TIME_BETWEEN_CHALLENGES", self.HIGH_WAIT_TIME_BETWEEN_CHALLENGES_APP.text())        self.setting.setValue("LOW_WAIT_TIME_BETWEEN_VOTES", self.LOW_WAIT_TIME_BETWEEN_VOTES_APP.text())        self.setting.setValue("HIGH_WAIT_TIME_BETWEEN_VOTES", self.HIGH_WAIT_TIME_BETWEEN_VOTES_APP.text())        self.setting.setValue("FILL_THRESHOLD", self.FILL_THRESHOLD_APP.text())        self.setting.setValue("BOOST", self.comboBoxBOOST_APP.currentText())        self.setting.setValue("HEADLESS", self.comboBoxHEADLESS_APP.currentText())        self.setting.setValue("WaitToReCheck", self.WaitToReCheck.text())        self.statusbar.showMessage(            f"Options saved ")        self.textEditLogs.append(            f"Options saved ")    def SaveLogin(self):        '''        save login credentials        '''        if self.userNameLineEdit.text() == "" or self.passwordLineEdit.text() == "":            self.statusbar.showMessage("Please enter your login credentials")            self.textEditLogs.append("Please enter your login details")        else:            self.setting.setValue("USERNAME", self.userNameLineEdit.text())            self.setting.setValue("PASSWORD", self.passwordLineEdit.text())            self.statusbar.showMessage(                f"Login details saved for {self.userNameLineEdit.text()}")            self.textEditLogs.append(                f"Login details saved for {self.userNameLineEdit.text()}")    def RunAppThreading(self):        threading.Thread(target=self.RunApp, daemon=True).start()    def RunApp(self):        print(self.HEADLESS)        if self.HEADLESS == 'True':            print('headless')            options = uc.ChromeOptions()            options.headless = True            self.driver = uc.Chrome(options=options)  # running        else:            self.driver = uc.Chrome()  # load driver        # open home page        self.go_to_home_page()        # log in        if self.setting.value("USERNAME") and self.setting.value("PASSWORD"):            self.log_in(self.setting.value("USERNAME"), self.setting.value("PASSWORD"))            self.statusbar.showMessage("Running...")            self.textEditLogs.append("Running...")        else:            self.statusbar.showMessage("Please enter your login details")            self.textEditLogs.append("Please enter your login details")        # run app  ,  if you need to run app forever and re check for challenges to vote on uncomment the while loop        # while self.Run:        self.textEditLogs.append("Checking for challenges to fill")        # check exposure meters of active challenges        self.driver.implicitly_wait(self.IMPLICIT_WAIT)        exposure_meters = self.driver.find_elements(By.XPATH,                                               "//div[@class='c-challenges-item__exposure__meter__arrow']")        self.statusbar.showMessage(f'{len(exposure_meters)} active challenges found.')        self.textEditLogs.append(f'{len(exposure_meters)} active challenges found.')        # add challenge id to list if exposure meter below threshold        unfilled_meters_idxs = []        for e, exp_meter in enumerate(exposure_meters):            rotation = float(exp_meter.get_attribute('style').split('rotate(')[1].split('deg)')[0])            print(rotation)            if rotation < self.FILL_THRESHOLD:                unfilled_meters_idxs.append(e)                print('Challenge found to fill')        # fill exposure meters        nb_vote_buttons = len(unfilled_meters_idxs)        if nb_vote_buttons == 0:            self.frameCounter.show()            self.CheckForSleep()        else:            self.frameCounter.hide()            for i, idx in enumerate(unfilled_meters_idxs):                time.sleep(np.random.randint(low=self.LOW_WAIT_TIME_BETWEEN_CHALLENGES,                                             high=self.HIGH_WAIT_TIME_BETWEEN_CHALLENGES))  # to keep request frequency low and realism high                self.statusbar.showMessage(f'filling challenge {i + 1}/{nb_vote_buttons}...')                try:                    self.fill_exposure(challenge_nb=idx)                except:                    pass        # boost all available        if self.BOOST == 'True':            self.boost_available()        # wait for a second        time.sleep(1)        # close window        self.driver.quit()        self.statusbar.showMessage("done Checking...")        self.textEditLogs.append("done Checking...")    def countdown(self, t , start_time):        while t:            mins, secs = divmod(t, 60)            timer = '{:02d}:{:02d}'.format(mins, secs)            time.sleep(1)            t -= 1            percent = (t / start_time) * 100            # print(percent , "%")            self.label.setText(str(t))    def CheckForSleep(self):        print('not found to fill')        if self.setting.value("WaitToReCheck"):            self.statusbar.showMessage(                f"Done Checking , all challenges is over {self.FILL_THRESHOLD}...Waiting for next check , wait time is {self.setting.value('WaitToReCheck')}")            self.textEditLogs.append(                f"Done Checking ,  all challenges is over {self.FILL_THRESHOLD}...Waiting for next check , wait time is {self.setting.value('WaitToReCheck')}")            self.countdown(int(self.setting.value('WaitToReCheck')), int(self.setting.value('WaitToReCheck')))            self.go_to_challenges_page()        else:            self.statusbar.showMessage(                f"Done Checking ,  all challenges is over {self.FILL_THRESHOLD}...Waiting for next check Wait for 1 second")            self.textEditLogs.append(                f"Done Checking ,  all challenges is over {self.FILL_THRESHOLD}...Waiting for next check , wait time is {self.setting.value('WaitToReCheck')}")            self.countdown(5, 5)    def go_to_home_page(self):        '''        go to page GuruShots home page        '''        self.driver.get('https://gurushots.com/')        # driver.fullscreen_window()        self.driver.set_window_size(1280, 1024)    def go_to_challenges_page(self):        '''        go to page that contains currently enrolled challenges        '''        self.driver.get('https://gurushots.com/challenges/my-challenges/current')        # driver.fullscreen_window()        self.driver.set_window_size(1280, 1024)    def log_in(self, email, password):        '''        log into GuruShots account with specified email address and password        store your credentials inside the credentials.py file        '''        try:            self.statusbar.showMessage('logging in...')            self.textEditLogs.append('logging in...')            # click login button            log_in_button = WebDriverWait(self.driver, self.LOGIN_WAIT).until(                EC.presence_of_element_located((By.XPATH, "//*[@ng-click='$ctrl.signin()']"))            )            log_in_button.click()            self.textEditLogs.append('Login button click...')            # send login credentials and hit enter to log in            email_field = WebDriverWait(self.driver, self.LOGIN_WAIT).until(                EC.presence_of_element_located((By.NAME, "email"))            )            self.textEditLogs.append('Adding Email...')            email_field.send_keys(email)            password_field = WebDriverWait(self.driver, self.LOGIN_WAIT).until(                EC.presence_of_element_located((By.NAME, "password"))            )            self.textEditLogs.append('adding Password...')            password_field.send_keys(password)            password_field.send_keys(Keys.RETURN)            self.statusbar.showMessage('logged in.')            self.textEditLogs.append('logged in...')        except Exception as e:            # self.textEditLogs.append(e)            print( e)    def fill_exposure(self, challenge_nb=0):        '''        fill exposure of specific challenge        '''        self.driver.implicitly_wait(self.IMPLICIT_WAIT)        vote_buttons = self.driver.find_elements(By.XPATH, "//div[@ng-click='$ctrl.vote()']")        try:            close_btn = self.driver.find_element(By.XPATH,                                                 "//*[@id=\"gs-app-main\"]/div/gs-modals/div/modal-vote/div[4]/div/div[2]")            close_btn.click()        except:            pass        try:            # click on challenge vote button            vote_button = vote_buttons[challenge_nb]            self.driver.implicitly_wait(self.IMPLICIT_WAIT)            vote_button.click()            # click LET'S GO button            self.driver.implicitly_wait(self.IMPLICIT_WAIT)            lets_go_button = self.driver.find_element(By.XPATH, "//div[text()=" + "\"LET'S GO\"" + "]")            lets_go_button.click()            # click 3 photos until exposure meter is full            last_photo_voted = 0            exposure_filled = False            while not exposure_filled:                # check if exposure full                self.driver.implicitly_wait(self.IMPLICIT_WAIT)                exposure_meter = self.driver.find_element(By.XPATH, "//div[@class='modal-vote__exposure-meter__arrow']")                rotation = float(exposure_meter.get_attribute('style').split('rotate(')[1].split('deg)')[0])                if rotation < 90.0:                    for i in range(last_photo_voted, last_photo_voted + 3):                        self.driver.implicitly_wait(self.IMPLICIT_WAIT)                        photo = self.driver.find_element(By.XPATH, f"//div[@id='vote-photo-{i}']")                        time.sleep(                            np.round(np.random.uniform(low=0.05, high=0.5), 2))  # wait between photo clicks for realism                        photo.click()                        last_photo_voted += 1                else:                    print('\texposure full.')                    exposure_filled = True            # click submit vote            self.driver.implicitly_wait(self.IMPLICIT_WAIT)            submit_vote_button = self.driver.find_element(By.XPATH, "//span[text()='SUBMIT VOTE']")            submit_vote_button.click()            # close vote window            self.driver.implicitly_wait(self.IMPLICIT_WAIT)            close_button = self.driver.find_element(By.XPATH,                                               "/html/body/app-root/div/div/gs-modals/div/modal-vote/div[4]/div/div[2]/div[2]")            close_button.click()        except Exception as e:            self.textEditLogs.append(e)            print('\t*** ERROR: ', e)            self.go_to_challenges_page()    def boost_available(self):        '''        find all available boosts and boost most pupular image for given challenge        '''        try:            # find available boosts            self.driver.implicitly_wait(self.IMPLICIT_WAIT)            boosts_abailable = self.driver.find_elements(By.CLASS_NAME,                                                    "challenge-action-button__content__boost-state__available")            nb_boosts_abailable = len(boosts_abailable)            print(f'{nb_boosts_abailable} available boosts found.')            # loop through available boosts and boost most pupular image            for i, boost_button in enumerate(boosts_abailable):                print(f'\tboosting {i + 1}/{nb_boosts_abailable}...')                # click boost                boost_button.click()                self.driver.implicitly_wait(self.IMPLICIT_WAIT)                # click on left-most picture                left_image = self.driver.find_element(By.XPATH, "//md-dialog-content/div[2]/div[3]/div[1]")                left_image.click()                self.driver.implicitly_wait(self.IMPLICIT_WAIT)        except Exception as e:            self.textEditLogs.append(e)            print('\t*** ERROR: ', e)            self.go_to_challenges_page()if __name__ == '__main__':    app = QApplication(sys.argv)    app.processEvents()    app.setWindowIcon(QIcon(GetPaths() + "/UI/icon.png"))    mw = MainWindow()    mw.show()    sys.exit(app.exec_())